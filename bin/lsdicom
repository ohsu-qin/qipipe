#!/usr/bin/env python
"""
Prints tab-delimited DICOM tag values.
"""

import sys
import os
import logging
import argparse
from collections import defaultdict
import dicom


def main(argv=sys.argv):
    # Parse the command line arguments.
    args = _parse_arguments()
    
    # Import the qipipe modules after parsing the log options.
    from qipipe.helpers.collection_helper import to_series
    from qipipe.helpers.dicom_helper import (iter_dicom_headers,
                                             select_dicom_tags)
    global iter_dicom_headers, select_dicom_tags
    from qipipe.helpers.image_hierarchy import ImageHierarchy
    global ImageHierarchy
    from qipipe.helpers.logging_helper import logger
    global logger

    # The summary tag list is set here rather than in the argument, since the
    # constant is imported after parsing the commmand line arguments.
    if args.summary:
        tags = ImageHierarchy.TAGS
    else:
        tags = args.tags
        if tags:
            tags = tags.split(',')

    # Print the tag value lines.
    _print_tag_values(
        tags, output=args.output, header=args.header, *args.files)

    return 0


def _parse_arguments():
    """Parses the command line arguments."""
    parser = argparse.ArgumentParser()
    
    # The log options.
    _add_log_options(parser)
    
    # The output content options.
    tag_grp = parser.add_mutually_exclusive_group()
    tag_grp.add_argument('-s', '--summary',
                         help='print only the Patient ID, Study Instance UID,'
                              'Series Instance UID and Instance Number tags',
                         action='store_true')
    tag_grp.add_argument('-t', '--tags',
                         help='the comma-separated tags to print'
                         '(default is all non-pixel, non-bracketed tags whose'
                         'value does not include a line break)')
    parser.add_argument(
        '-n', '--no-header', help='omit the tag name header line',
        dest='header', action='store_false')
    parser.add_argument(
        '-o', '--output', help='print the values to the given file')
    
    # The input file argument.
    parser.add_argument(
        'files', help='the DICOM files or directories to list (default stdin)',
        metavar='FILE', nargs='+')

    return parser.parse_args()


def _add_log_options(parser):
    """
    Adds the standard --log, --quiet, --verbose and --debug options to the
    given command line arugment parser.
    """
    parser.add_argument('-l', '--log', help='the log file', metavar='FILE')
    verbosity_grp = parser.add_mutually_exclusive_group()
    verbosity_grp.add_argument(
        '-q', '--quiet', help="only log error messages", dest='log_level',
        action='store_const', const=logging.ERROR)
    verbosity_grp.add_argument(
        '-d', '--debug', help='log debug messages', dest='log_level',
        action='store_const', const=logging.DEBUG)

def _configure_log(**opts):
    """
    Configures the logger. This method should be called before importing
    any qipipe or nipype module.

    :param opts: the following keyword options:
    :keyword log: the log file
    :keyword log_level: the log level
    """
    log_cfg = {}
    if 'log' in opts:
        log_file = os.path.abspath(opts.pop('log'))
        log_cfg['filename'] = log_file
        # Set the Nipype log directory environment variable
        # before importing qipipe. See the comments below.
        log_dir = os.path.dirname(log_file)
        if log_dir:
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            os.environ[NIPYPE_LOG_DIR_ENV_VAR] = log_dir
    if 'log_level' in opts:
        log_cfg['level'] = opts.pop('log_level')
    # The Nipype log directory environment variable must be
    # set before importing a nipype module which uses the
    # nipype logger. qipipe imports the Nipype pipeline module.
    # Therefore, import qipipe.helpers here after setting the
    # log directory environment variable above.
    from qipipe.helpers import logging_helper
    # Make the qipipe logger.
    logging_helper.configure(**log_cfg)


def _print_tag_values(tags, *files, **opts):
    """
    Prints the tab-delimited tag value lines.
    
    :param tags: the tags to print (default all tags)
    :param files: the DICOM files
    :param opts: the print options
    :keyword output: the destination (default stdout)
    :keyword header: flag indicating whether to print a header line (default True)
    """
    # The default tags include any tag defined in at least one file.
    # This preparatory step requires reading each DICOM file to collect
    # the tags before rereading the file to print the tag values.
    if not tags:
        tags = _collect_default_tags(*files)

    # The print output.
    output = opts.get('output') or sys.stdout

    # Print the header, if necessary.
    if opts['header']:
        print >> output, '\t'.join(tags)

    # Print the tags in each DICOM file.
    logger(__name__).debug('Printing the DICOM tag values...')
    for ds in iter_dicom_headers(*files):
        # The DICOM tag value dictionary.
        tdict = _read_tags(ds, *tags)
        # If there is at least one tag with a valid value, then print the value
        # line.
        if tags:
            # Augment the tag dictionary with a default empty string value for
            # a missing tag.
            dd = defaultdict(str)
            dd.update(tdict)
            # Collect the (possibly empty) string values for each tag.
            values = [str(dd[t]) for t in tags]
            # Print the tab-delimited tag value line.
            print >> output, '\t'.join(values)


def _collect_default_tags(*files):
    """
    Collects the tags which occur in at least one of the given files.
    
    :param fps: the DICOM file paths, streams or datasets
    :return: the tags with a valid value
    """
    tag_set = set()
    for ds in iter_dicom_headers(*files):
        tdict = _read_tags(ds)
        tag_set.update(tdict.iterkeys())

    # Sort the tags
    tags = list(tag_set)
    tags.sort()

    return tags


def _read_tags(ds, *tags):
    """
    Reads the DICOM tags in the given file
    Filters the given tag dictionary to exclude empty or multi-line tag values.
    
    :param ds: the pydicom dataset
    :param tags: the DICOM tags to read (default all tags)
    :return: the filtered tag dictionary
    """
    tdict = select_dicom_tags(ds, *tags)
    return {t: v for t, v in tdict.iteritems() if v and '\n' not in str(v)}

if __name__ == '__main__':
    sys.exit(main())
