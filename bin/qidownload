#!/usr/bin/env python
"""
Downloads files from XNAT.
"""

import sys, os, re
import argparse
import logging
from collections import defaultdict
# Defer importing the application modules until the logging level has been set.

SESSION_LBL_PAT = re.compile("^(\w+)_(\w+)_(\w+)$")
"""The *project*``_``*subject*``_``*session* XNAT label matcher."""

def main(argv=sys.argv):
    # Parse the command line arguments.
    args = _parse_arguments()
    
    # Configure the logger.
    if args.log:
        logging.basicConfig(filename=args.log)
    if args.log_level:
        logging.getLogger().setLevel(args.log_level)
    
    # Import the application now, after logging has been set.
    from qipipe.helpers.project import project
    from qipipe.helpers import xnat_helper
    from qipipe.interfaces import XNATDownload
    
    # The download options.
    if args.reconstruction:
        dl_opts = dict(reconstruction=args.reconstruction)
    elif args.assessor:
        dl_opts = dict(assessor=args.assessor)
    else:
        dl_opts = {}
    if args.format:
        dl_opts['format'] = args.format
    if args.output:
        dl_opts['dest'] = args.output
    
    # Parse the XNAT session label arguments.
    prj_sess_dict = _parse_session_labels(args.sessions)
    # Register the session images.
    with xnat_helper.connection() as xnat:
    for prj, sessions in prj_sess_dict.iteritems():
        for sbj, sess in sessions:
            tgt_dir = os.path.join(dest, prj, sbj, sess)
            # Download the files.
            download = XNATDownload(**dl_opts)
            result = download.run()
    
    return 0

def _parse_session_labels(labels):
    """
    Parses the given XNAT session labels into (subject, session) tuples grouped
    by project.
    
    :param labels: the labels to parse
    :return: the {project: [(subject, session), ...]} dictionary
    """
    prj_sess_dict = defaultdict(list)
    for label in labels:
        prj, sbj, sess = _parse_session_label(label)
        prj_sess_dict[prj].append(tuple([sbj, sess]))
    
    return prj_sess_dict

def _parse_session_label(label):
    """
    Parses the given XNAT session label into project, subject and session based
    on the ``qipipe`` naming standard.
    
    :param label: the label to parse
    :return: the [project, subject, session] list
    """
    match = SESSION_LBL_PAT.match(label)
    if not match:
        raise ValueError("The XNAT session label argument is not in"
            " project_subject_session format: %s" % label)
    
    return match.groups()
    

def _parse_arguments():
    """Parses the command line arguments."""
    parser = argparse.ArgumentParser()
    
    # The logging level.
    verbosity_grp = parser.add_mutually_exclusive_group()
    verbosity_grp.add_argument('-q', '--quiet', help="don't print messages",
        dest='log_level', action='store_const', const=logging.ERROR)
    verbosity_grp.add_argument('-v', '--verbose', help='print informational messages',
        dest='log_level', action='store_const', const=logging.INFO)
    verbosity_grp.add_argument('-d', '--debug', help='print debug messages',
        dest='log_level', action='store_const', const=logging.DEBUG)

    # The remaining options.
    target_grp = parser.add_mutually_exclusive_group()
    target_grp.add_argument('-r', '--reconstruction', help='the XNAT reconstruction name')
    target_grp = parser.add_mutually_exclusive_group()
    target_grp.add_argument('-a', '--assessor', help='the XNAT assessor name')
    parser.add_argument('-f', '--format', help='the file format (default NiFTI)')
    parser.add_argument('-l', '--log', help='the log file', metavar='FILE')
    parser.add_argument('-o', '--output',
        help='the destination directory (default current directory)',
        metavar='DIR')
    
    # The input sessions to process.
    parser.add_argument('sessions', help='the input XNAT sessions to register',
        nargs='+')
    
    return parser.parse_args()
    

if __name__ == '__main__':
    sys.exit(main())
