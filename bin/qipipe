#!/usr/bin/env python
"""
Runs the QIN pipeline.
"""

import sys
import os
import imp
import argparse

# Import the command helper by path, since the log options must be
# processed before importing any qipipe module.
cmd = imp.load_source('command', 
                      os.path.dirname(__file__) + '/../qipipe/helpers/command.py')


def main(argv=sys.argv):
    # Parse the command line arguments.
    inputs, opts = _parse_arguments()

    # Configure the logger.
    cmd.configure_log(opts)

    # Import the qipipe pipeline module after configuring the logger.
    from qipipe.pipeline import qipipeline as qip

    # Run the QIN workflow.
    qip.run(*inputs, **opts)

    return 0


def _parse_arguments():
    """
    Parses the command line arguments.

    :return: the (inputs, options) tuple, where inputs is the non-option
        arguments and options is an {option: value} dictionary
    """
    parser = argparse.ArgumentParser()
    
    # The log options.
    cmd.add_log_options(parser)

    # The actions.
    parser.add_argument('--stage', dest='actions', action='append_const',
                        const='stage', help='stage the input DICOM files')
    parser.add_argument('--register', dest='actions', action='append_const',
                        const='register', help='register the scans')
    parser.add_argument('--model', dest='actions', action='append_const',
                        const='model', help='model the realigned images')
    parser.add_argument('--dry-run', action='store_true',
                        help='Prepare but do not run the pipeline')

    # The AIRC collection to stage.
    coll_grp = parser.add_mutually_exclusive_group()
    coll_grp.add_argument('-b', '--breast', help='the breast TCIA collection',
                          dest='collection', action='store_const',
                          const='Breast')
    coll_grp.add_argument('-s', '--sarcoma',
                          help='the sarcoma TCIA collection',
                          dest='collection', action='store_const',
                          const='Sarcoma')

    # The output and work options.
    parser.add_argument('-o', '--output',
                        help='the destination directory'
                             ' (default current directory)',
                        metavar='DIR', dest='dest')
    parser.add_argument('-w', '--work',
                        help='the work directory'
                             ' (default a new temp directory)',
                        metavar='DIR', dest='base_dir')

    # The mask and time series arguments.
    parser.add_argument('--mask', help="the mask XNAT resource name",
                        metavar='LABEL')
    parser.add_argument('--scan-time-series',
                        help="the 4D scan time series XNAT resource name",
                        metavar='LABEL')

    # The registration arguments.
    parser.add_argument('--registration',
                        help='the XNAT registration resource name',
                        metavar='RESOURCE')
    technique_grp = parser.add_mutually_exclusive_group()
    technique_grp.add_argument('--ants',
                               help="ANTS registration (the default)",
                               dest='technique', action='store_const',
                               const='ants')
    technique_grp.add_argument('--fnirt', help="FNIRT registration",
                               dest='technique', action='store_const',
                               const='fnirt')
    technique_grp.add_argument('--mock', help="Mock registration",
                               dest='technique', action='store_const',
                               const='mock')

    # The input subject directories or XNAT labels to process.
    parser.add_argument('inputs', help='the input AIRC DICOM subject directory'
                        ' or XNAT session label if staging is not performed',
                        metavar='INPUT', nargs='*')

    args = vars(parser.parse_args())
    nonempty_args = dict((k, v) for k, v in args.iteritems() if v != None)

    return nonempty_args.pop('inputs'), nonempty_args


if __name__ == '__main__':
    sys.exit(main())
