#!/usr/bin/env python
"""
Stages DICOM files for submission to TCIA and XNAT.
"""

import sys
import os
import getopt
from qipipe.pipelines import stage

import logging
logger = logging.getLogger('qipipe')

help_message = """
qistage options DIR...
Options:
    -b --breast\tThe Breast collection
    -s --sarcoma\tThe Sarcoma collection
    -o --output DIR\tThe destination directory
    -p --pattern PAT\tThe session subdirectory pattern (default [vV]isit*)
    -q, --quiet\t\tSuppress messages
    -v, --verbose\tPrint verbose messages
    -h --help\t\tPrint this help message
"""


class Usage(Exception):

    def __init__(self, msg):
        self.msg = msg


def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        try:
            opts, args = getopt.getopt(argv[1:], 'bho:p:qsv', ['breast', 'help', 'output=', 'pattern=', 'quiet', 'sarcoma', 'verbose'])
        except getopt.error, msg:
            raise Usage(msg)

        # Parse the options.
        dest = collection = None
        # The additional group options.
        gopts = {}
        for opt, val in opts:
            if opt in ('-b', '--breast'):
                collection = 'Breast'
            elif opt in ('-s', '--sarcoma'):
                collection = 'Sarcoma'
            elif opt in ('-o', '--output'):
                dest = val
            elif opt in ('-p', '--pattern'):
                gopts['session'] = val
            elif opt in ('-q', '--quiet'):
                logger.setLevel('ERROR')
            elif opt in ('-v', '--verbose'):
                logger.setLevel('DEBUG')
            elif opt in ('-h', '--help'):
                print help_message
                return 0

        # Validate the required options.
        if not dest:
            raise Usage("Required output option is not set.")
        if not collection:
            raise Usage("Neither the breast nor the sarcoma collection option is set.")
        
        # Run the staging workflow.
        stage.run(collection, dest, *args, **gopts)

    except Usage, err:
        print >> sys.stderr, sys.argv[0].split('/')[-1] + ': ' + str(err.msg)
        return 2

    return 0


if __name__ == '__main__':
    sys.exit(main())
