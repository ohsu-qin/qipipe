#!/usr/bin/env python
"""
Runs the QIN pipeline.
"""

import sys, os
import argparse
import logging
# Defer importing the application modules until the logging level has been set.


def main(argv=sys.argv):
    # Parse the command line arguments.
    args = _parse_arguments()
    
    # Configure the logger.
    if args.log:
        logging.basicConfig(filename=args.log)
    if args.log_level:
        logging.getLogger().setLevel(args.log_level)
    
    # Import the application now, after logging has been set.
    from qipipe.pipelines import qipipeline as qip
    from qipipe.helpers.ast_config import read_config
    
    # The options.
    opts = {}
    if args.output:
        opts['dest'] = args.output
    if args.work:
        opts['work'] = args.work
    if args.staging:
        opts['staging'] = dict(read_config(args.staging))
    elif args.staging == False:
        opts['staging'] = False
    if args.registration:
        opts['registration'] = dict(read_config(args.registration))
    elif args.registration == False:
        opts['registration'] = False
    if args.pk_mapping:
        opts['pk_mapping'] = dict(read_config(args.pk_mapping))
    elif args.pk_mapping == False:
        opts['pk_mapping'] = False
    if args.force:
        opts['force'] = True
    
    # Run the QIN workflow.
    qip.run(args.collection, *args.subject_dirs, **opts)

    return 0

def _parse_arguments():
    """Parses the command line arguments."""
    parser = argparse.ArgumentParser()

    # The AIRC collection to process.
    coll_grp = parser.add_mutually_exclusive_group(required=True)
    coll_grp.add_argument('-b', '--breast', help='the breast TCIA collection',
        dest='collection', action='store_const', const='Breast')
    coll_grp.add_argument('-s', '--sarcoma', help='the sarcoma TCIA collection',
        dest='collection', action='store_const', const='Sarcoma')
    
    # The logging level.
    verbosity_grp = parser.add_mutually_exclusive_group()
    verbosity_grp.add_argument('-q', '--quiet', help="don't print messages",
        dest='log_level', action='store_const', const=logging.ERROR)
    verbosity_grp.add_argument('-v', '--verbose', help='print informational messages',
        dest='log_level', action='store_const', const=logging.INFO)
    verbosity_grp.add_argument('-d', '--debug', help='print debug messages',
        dest='log_level', action='store_const', const=logging.DEBUG)
    
    # The log, work and output options.
    parser.add_argument('-l', '--log', help='the log file', metavar='FILE')
    parser.add_argument('-o', '--output', help='the destination directory (default current directory)',
        metavar='DIR')
    parser.add_argument('-w', '--work', help='the work directory (default a new temp directory)',
        metavar='DIR')
    
    # The dangerous force option.
    parser.add_argument('-f', '--force', help='reload existing XNAT subjects',
        action='store_true')
    
    # The workflow configurations.
    parser.add_argument('--staging', help="the staging configuration file",
         metavar='FILE', dest='staging')
    reg_grp = parser.add_mutually_exclusive_group()
    reg_grp.add_argument('--registration', help="the registration configuration file",
        metavar='FILE', dest='registration')
    reg_grp.add_argument('--no-registration', help='only perform the staging workflow',
        dest='registration', action='store_false')
    pk_mapping_grp = parser.add_mutually_exclusive_group()
    pk_mapping_grp.add_argument('--pk-mapping', help="the PK mapping configuration file",
        metavar='FILE', dest='pk_mapping')
    pk_mapping_grp.add_argument('--no-pk-mapping', help="don't perform the PK mapping workflow",
        dest='pk_mapping', action='store_false')
    
    # The input subject directories to process.
    parser.add_argument('subject_dirs', help='the input AIRC DICOM subject directories',
        metavar='DIR', nargs='+')

    return parser.parse_args()

    
if __name__ == '__main__':
    sys.exit(main())
