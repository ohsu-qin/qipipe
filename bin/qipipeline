#!/usr/bin/env python
"""
Runs the QIN pipeline.
"""

import sys
import os
import argparse
from qipipe.pipeline import qipipeline as qip
from qipipe.helpers import logging_helper


def main(argv=sys.argv):
    # Parse the command line arguments.
    inputs, opts = _parse_arguments()

    # Configure the logger.
    log_cfg = {}
    if 'log' in opts:
        log_cfg['filename'] = opts.pop('log')
    if 'log_level' in opts:
        log_cfg['level'] = opts.pop('log_level')
    logging_helper.configure(**log_cfg)

    # Run the QIN workflow.
    qip.run(*inputs, **opts)

    return 0


def _parse_arguments():
    """
    Parses the command line arguments.

    :return: the (inputs, options) tuple, where inputs is the non-option
        arguments and options is an {option: value} dictionary
    """
    parser = argparse.ArgumentParser()

    # The AIRC collection to process.
    coll_grp = parser.add_mutually_exclusive_group()
    coll_grp.add_argument('-b', '--breast', help='the breast TCIA collection',
                          dest='collection', action='store_const', const='Breast')
    coll_grp.add_argument(
        '-s', '--sarcoma', help='the sarcoma TCIA collection',
        dest='collection', action='store_const', const='Sarcoma')

    # The XNAT project id.
    parser.add_argument(
        '-p', '--project', help='the XNAT project (default is QIN)')

    # The logging level.
    verbosity_grp = parser.add_mutually_exclusive_group()
    verbosity_grp.add_argument('-q', '--quiet', help="don't print messages",
                               dest='log_level', action='store_const', const='ERROR')
    verbosity_grp.add_argument(
        '-v', '--verbose', help='print informational messages',
        dest='log_level', action='store_const', const='INFO')
    verbosity_grp.add_argument('-d', '--debug', help='print debug messages',
                               dest='log_level', action='store_const',
                               const='DEBUG')

    # The log, output and work options.
    parser.add_argument('-l', '--log', help='the log file', metavar='FILE')
    parser.add_argument(
        '-o', '--output', help='the destination directory (default current directory)',
        metavar='DIR', dest='dest')
    parser.add_argument(
        '-w', '--work', help='the work directory (default a new temp directory)',
        metavar='DIR', dest='base_dir')

    # The mask and reference arguments.
    parser.add_argument('--mask', help="the mask XNAT reconstruction name",
                        metavar='RECON')
    parser.add_argument('--reference', help="the reference XNAT reconstruction name",
                        metavar='RECON')

    # The registration arguments.
    parser.add_argument(
        '--registration', help='the XNAT registration reconstruction name',
        metavar='RECON')
    parser.add_argument('--no-registration', help='skip registration',
                         dest='skip_registration', action='store_true', default=None)
    technique_grp = parser.add_mutually_exclusive_group()
    technique_grp.add_argument('--ants', help="ANTS registration (the default)",
                               dest='technique', action='store_const', const='ANTS')
    technique_grp.add_argument('--fnirt', help="FNIRT registration",
                               dest='technique', action='store_const', const='FNIRT')

    # The modeling argument.
    parser.add_argument('--no-modeling', help='disable the modeling workflow',
                        dest='skip_modeling', action='store_true', default=None)

    # The input subject directories or XNAT labels to process.
    parser.add_argument('inputs', help='the input AIRC DICOM subject directory'
                        ' or XNAT session label if staging is not performed',
                        metavar='INPUT', nargs='+')

    args = vars(parser.parse_args())
    nonempty_args = dict((k, v) for k, v in args.iteritems() if v != None)

    return nonempty_args.pop('inputs'), nonempty_args


if __name__ == '__main__':
    sys.exit(main())
