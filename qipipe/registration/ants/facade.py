import os
import shutil
from .similarity_metrics import *
from .template import create_template
from .warp_transform import warp
from .ants_error import ANTSError

import logging
logger = logging.getLogger(__name__)


def register(*in_files, **opts):
    """
    Registers the images in the given path.

    If the reference fixed image is missing, then it is generated by calling
    create_dce_template.

    @param in_files: the images to register
    @param opts: the registration options
    @keyword output: the output directory (default is the input directory)
    @keyword work: the working directory for intermediate results (default is the output directory)
    @keyword metric: the similarity metric (default is cross-correlation)
    @keyword reference: the fixed reference image (default is generated)
    @return: the source => registered file dictionary
    """
    return ANTS(**opts).register(*in_files)


def create_dce_template(files, metric=None):
    """
    Generates a fixed reference template for registering the given image files.
    
    If there more than 10 but less than 100 input files, then the reference
    image is generated from at most 50 input files starting at the fifth input file
    in sort order.
    
    If there are at least 100 input files, then the reference image is generated from
    50 input files consisting of a uniformally-sampled subset starting at the tenth
    input file and separated by no more than five input files in sort order.
    For example, if there are 225 images named image0001.dcm to image0225.dcm, then
    the reference template averages the files image0010.dcm, image0014.dcm, ...,
    image0206.dcm, image0210.dcm.
    
    Otherwise, if there are 10 or fewer input files, then the reference image
    is generated from all of the given input files.

    @param files: the images to average
    @param metric: the similarity metric (default is cross-correlation)
    @return: the reference template
    """
    # If there are many input files, then build the template with a subset.
    if len(files) >= 100:
        tfiles = []
        step = min(5, (len(files) - 20) / 50)
        for i in range(0, 49):
            tfiles.append(files[9 + i * step])
    elif len(files) > 10:
        tfiles = files[4:min(54, len(files))]
    else:
        tfiles = files
    return create_template(tfiles, metric=metric)
    
    
class ANTS(object):
    """ANTS wraps the ANTS filters.
    """

    def __init__(self, output=None, work=None, metric=None, reference=None):
        """Initializes this ANTS instance.

        @param output: the output directory (default is the input directory)
        @param work: the working directory for intermediate results (default is the output directory)
        @param metric: the similarity metric
        @param reference: the fixed reference image (default is generated)
        """
        
        self.metric = metric
        self.output = output
        self.work = work
        
        # Make the reference an absolute path, since register switches to the work directory. 
        if reference:
            self.reference = os.path.abspath(reference)
        else:
            self.reference = None
    
    def register(self, *in_files):
        """Registers the given images using a symmetric diffeomorphic deformation.

        @param *in_files: the images to register
        @return: the source => registered file name dictionary
        """
        
        # The work directory.
        if self.work:
            work = self.work
        elif self.output:
            work = self.output
        else:
            work = os.getcwd()
        if not os.path.exists(work):
            os.makedirs(work)
        
        # Link the source images in the work directory, if necessary.
        for f in in_files:
            parent, fname = os.path.split(f)
            if not os.path.samefile(parent, work):
                self._link(f, work)

        # Register the images.
        logger.info("Registering the images in %s..." % work)
        registered = dict()
        cwd = os.getcwd()
        os.chdir(work)
        try:
            # Generate the default fixed image, if necessary.
            if not self.reference:
                self.reference = create_dce_template(files, self.metric)
            # Register each moving image to the fixed image.
            for moving in files:
                registered[moving] = warp(moving, self.reference, self.metric)
        finally:
            os.chdir(cwd)
        logger.info("Registered the images in %s." % work)
        
        # If the output area is designated, then copy the registered images to the
        # output area.
        if self.output:
            if not os.path.exists(self.output):
                os.makedirs(self.output)
            if not os.path.samefile(self.output, work):
                logger.info("Copying the registered images from %s to %s..." % (work, self.output))
                for fn in registered.values():
                    wf = os.path.join(work, fn)
                    of = os.path.join(self.output, fn)
                    if os.path.exists(of):
                        os.remove(of)
                    shutil.copyfile(wf, of)
                logger.info("Copied the registered images to %s." % self.output)
        
        return registered

    def _link(self, source, dest, fname=None):
        """
        Links the given file in the source directory to the destination.
        
        @param source: the file to link
        @param dest: the destination directory
        @param fname: the destination file name (default source file name)
        @raise ANTSError: if there is an existing non-link destination file
        """

        source = os.path.abspath(source)
        _, fname = os.path.split(source)
        dest_file = os.path.join(dest, fname)
        src_file = os.path.join(source, fname)
        if os.path.exists(dest_file):
            if os.path.islink(dest_file):
                if os.path.samefile(src_file, dest_file):
                    return
                else:
                    logger.info("Removing the existing link from %s to %s..." % (src_file, dest_file))
                    os.remove(dest_file)
            else:
                raise ANTSError("Non-link destination file exists: %s" % dest_file)
        logger.info("Linking the source file %s to %s..." % (source, dest))
        os.symlink(src_file, dest_file)
        
    